---
title: ""
author: ""
date: "2/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 제3장 데이터 구조

<hr>

#### 3.1 데이터의 기본형태

\- 벡터

\- 행렬

\- 배열

\- 리스트

\- 데이터 프레임

\<br\>\<br\>

\#\#\#\# 3.2 벡터

\- 가장 기본이되는 자료 객체

\- 수치형 문자형 논리형 사용 가능

\- 모든 원소는 동일해야 함

\<br\>\<br\>

\#\#\#\#\# 3.2.1 생성방법

\- c() : 직접 입력

\- scan() : 직접 입력

\- seq() : 조건에 따른 벡터 생성

\- rep() : 자료값을 반복해 생성

\<br\>\<br\>

\`\`\`{r}

\# c() : 수치형

c(3, 4, 5, 6, 7)

c(3:7)

c(7, 3, 5, 4, 6)

\`\`\`

\`\`\`{r}

\# c() : 문자형

c("1", "Korea", "National", "Open", "University")

v1 \<- c("1", "Korea", "National", "Open", "University")

length(v1)

\`\`\`

\`\`\`{r}

\# c() : 논리형

c(T, F, T)

c(TRUE, FALSE, TRUE)

\`\`\`

\`\`\`{r}

\# scan()

scan()

\# 1: 3 4 5

\# 4: 6 7

\# 6:

\# Read 5 items

scan(sep = ",")

\# 1: 3

\# 2: 4,5

\# 4: 6,7

\# 6:

\# Read 5 items

\`\`\`

\`\`\`{r}

\# seq()

seq(from=3, to=7, by=1)

seq(to=7, from=3, by=1)

seq(by=1, from=3, to=7)

seq(3, 7, 1)

\`\`\`

\`\`\`{r}

\# seq()

seq(from=3, to=7, length=3)

seq(from=1, by=0.05, along=1:5)

seq(from=1, to=5, along=1:6)

\`\`\`

\`\`\`{r}

\# rep()

rep(c(1,2), times=2)

rep(1:2, times=2)

rep(c(2,4), times=c(2,1))

rep(c(2,4), each=2)

rep(c(2,4,8),length=5)

\`\`\`

\<br\>

\#\#\#\#\# 3.2.2 벡터 자료의 편집

\- [] : 벡터의 일부 원소를 추출

\- replace() : 일부 자료를 대체

\- append() : 조건에 따른 위치에 자료 삽입

\- sort() : 자료를 정렬

\- rank() : 자료의 순위를 출력

\- order() : 오름차순에 의한 자료의 위치값 출력

\<br\>\<br\>

\`\`\`{r}

v1 \<- c(11:28) \# 11에서 28까지의 값을 갖는 벡터 v1 생성

v1

v1[c(3,5)] \# v1의 세번째와 다섯번째 값을 출력

v1[v1\>15] \# v1의 원소 중 15보다 큰 값을 출력

v1[c(-2,-4)] \# v1의 원소 중 두번째와 네번째 값을 삭제하고 출력

\`\`\`

\`\`\`{r}

v2 \<- c(3:7)

v2

replace(v2, 2, 10)

append(v2,8,after=5)

v3 \<- append(v2,8,after=5)

v3

\`\`\`

\`\`\`{r}

x \<- c(rep(3,3), seq(3,7,2), rev(seq(3,7,length=3)), rep(4,3))

x

sort(x) \# x를 오름차순으로 정렬

rank(x) \# 자료의 순위를 출력

order(x) \# 오름차순의한 자료의 위치 출력

\`\`\`

\<br\>\<br\>

\*\*벡터와 관련된 여러가지 함수\*\*

\|함수\|설명\|사용예\|

\|:-:\|:-:\|:-:\|

\|scan\|자료를 화면에서 직접 입력\|scan(), scan("data")\|

\|c\|자료를 조합하여 벡터 생성\|c(1,2,3,4), c("yes", "no")\|

\|:\|수치적 수열을 나타냄\|1:5.
1:-1\|

\|seq\|수치적 수열을 나타냄\|seq(-pi,pi,5)\|

\|vector\|벡터로 초기화\|vector("complex", 5)\|

\|logical\|logical 벡터로 초기화\|logical(3)\|

\|numeric\|numeric 벡터로 초기화\|numeric(4)\|

\|complex\|complex 벡터로 초기화\|complex(5)\|

\|character\|character 벡터로 초기화\|character(6)\|

\<br\>\<br\>

\#\#\#\# 3.3 행렬

\<br\>

\*\*행렬의 주요속성\*\*

\|속성\|설명\|

\|:---:\|:---:\|

\|length\|자료의 개수\|

\|mode\|자료의 형태\|

\|dim\|행렬의 열과 갯수\|

\|dimnames\|행과 열의 이름\|

\<br\>\<br\>

\`\`\`{r}

matr \<- matrix(1:9, nrow=3)

matr

length(matr)

mode(matr)

dim(matr)

\`\`\`

\<br\>\<br\>

\#\#\#\#\# 3.3.1 행렬의 생성

\- matrix()

\- cbind() : 벡터를 열기준으로 병합

\- rbind() : 벡터를 행기준으로 병합

\- dim() : 행과 열의 갯수를 직접 지정

\`\`\`{r}

r1 \<- c(1, 2, 3)

r2 \<- c(4, 5, 6)

r3 \<- c(7, 8, 9)

rbind(r1, r2, r3)

c1 \<- c(1:3)

c2 \<- c(4:6)

c3 \<- c(7:9)

cbind(c1, c2, c3)

m1 \<- 1:9

dim(m1) \<- c(3, 3)

m1

\`\`\`

\<br\>\<br\>

\#\#\#\# 3.3.2 행렬의 연산

\- [] : 행렬의 일부 원소를 추출

\- apply() : 행 또는 열의 연산

-sweep() : 행 또는 열의 연산

\`\`\`{r}

mat \<- matrix(c(1:9), ncol=3, byrow=1)

mat

mat[1,]

mat[,3]

mat[mat[,3]\> 4, 2]

mat[2, 3]

\`\`\`

\`\`\`{r}

\# apply 함수

Height \<- c(140, 155, 142, 175)

size.1 \<- matrix(c(130, 26, 110, 24, 118, 25, 112, 25), ncol=2, byrow=T, dimnames=list(c("Lee", "Kim", "Park", "Choi"), c("Weight", "Height")))

size = cbind(size.1, Height)

size

colmean \<- apply(size, 2, mean)

colmean

rowmean \<- apply(size, 1, mean)

rowmean

colvar \<- apply(size, 2, var)

colvar

rowvar \<- apply(size, 1, var)

rowvar

\`\`\`

\`\`\`{r}

\# sweep 함수 (기본연산은 - 로 지정되어 있음)

sweep(size, 2, colmean)

sweep(size, 1, rowmean)

sweep(size, 1, c(1,2,3,4), "+")

sweep(size, 1, c(1,2,3,4), "-")

\`\`\`

\<br\>

\#\#\#\#\# 행렬의 연산과 관련된 주요 함수와 기능

\|연산자 및 함수\|기능\|사용법\|

\|:----:\|:-----:\|:----:\|

\|t\|전치행렬을 구하는 함수\|t(A)\|

\|%\*%\|행렬의 곱셈\|A%\*%B\|

\|crossprod\|t(A)%\*%B\|crossprod(A,B)\|

\|outer\|외적을 구하는 함수\|outer(A,B)\|

\|svd\|sigular value 분해\|svd(A)\|

\|qr\|QR 분해함수\|qr(A)\|

\|solve\|방정식의 근을 구하는 함수\|solve(A,B)\|

\|\|역행렬을 구하는 함수\|solve(A)\|

\|eigen\|고유치와 고유벡터 함수\|eigen(A)\|

\|chol\|choleski 분해 함수\|chol(A)\|

\> \*\*예제\*\*\<br\>

\> 1에서 4까지의 값을 갖는 열 기준 행렬 m1 과 5에서 8까지의 값을 갖는 열 기준의 행렬 m2 를 생성하고 두 행렬의 곱, m1 의 전치 행렬 및 m1 의 역행렬을 구해보자

\`\`\`{r}

m1 = matrix(1:4, ncol=2)

m1

m2 = matrix(5:8, nrow=2)

m2

m1%\*%m2

solve(m1)

t(m1)

\`\`\`

\<br\>\<br\>

\#\#\#\# 3.4 배열

\- 행렬을 2차원이상으로 확장시킨 객체

\- 2차원 구조로 이뤄진 행렬도 일종의 배열

\- 일반적으로 3차원 이상의 데이터 객체를 배열이라 함

\|속성\|설명\|

\|:-----:\|:-----:\|

\|length\|자료의 개수\|

\|mode\|자료의 형태\|

\|dim\|각 차원 벡터의 크기\|

\|dimnames\|각 차원 리스트의 이름\|

\> \*\*예제\*\*

\>

\> 다음은 배열을 생성하는 데 사용되는 array() 함수를 이용하여 1에서 18까지의 원소를 갖는 3행 3열의 행렬 2개를 생성하는 예제이다.
각 차원의 이름을 ar1 및 ar2 로 지정하고, 행과 열의 이름을 row1, row2, row3, col1, col2, col3 로 지정하여 출력한다.
length(), mode(), dim(), dimnames() 를 이용하여 각 속성을 파악해보자

\`\`\`{r}

arr \<- array(1:24, c(3,3,2))

dimnames(arr)\<-list(paste("row", c(1:3)), paste("col", c(1:3)), paste("ar", c(1:2)))

arr

length(arr)

mode(arr)

dim(arr)

dimnames(arr)

\`\`\`

\> \*\*예제\*\*

\>

\> array() 함수를 이용하여 1에서 6까지 자료로 1차원 및 2차원 배열을 생성해보고, 1에서 8까지 값으로 3차원 배열을 만들어 보자.
또한 dim() 함수를 이용하여 1\~24까지 자료로 3행 4열 행렬 2개를 생성해 보자

\`\`\`{r}

array(1:6)

array(1:6, c(2,3))

array(1:8, c(2,2,2))

arr \<- c(1:24)

dim(arr) \<- c(3,4,2)

arr

\`\`\`

\> \*\*예제\*\*

\>

\> 다음은 리스트를 생성하는 데 사용되는 list() 함수를 이용하여 2개의 벡터와 1개의 문자열을 가진 리스트를 생성하고 속성을 출력하는 예제이다.

\`\`\`{r}

a \<- 1:18

b \<- 11:15

klist \<- list(vec1=a, vec2=b, descrip="example")

length(klist)

mode(klist)

names(klist)

\`\`\`

\<br\>\<br\>

\#\#\#\#\# 3.5.1 리스트의 생성 및 추출

\- [[]] : 리스트에서 성분 추출

\- 성분의 이름이 부여됐다면 \$ 연산자로 구분

\- [] : 성분내의 특정 원소 추출

\> \*\*예제\*\*

\>

\> list() 함수를 이용하여 "A"라는 문자와 1에서 8까지의 원소를 갖는 벡터를 성분으로 하는 list1를 생성하자.
list1의 세번째 성분으로 논리값 T, F를 갖는 벡터를 추가하고, 두번째 ㅅ어분의 아홉번째 원소로 9를 추가해 보자

\`\`\`{r}

list1 \<- list("A", 1:8)

list1

list1[[3]] \<- list(c(T,F))

list1[[2]][9] \<- 9

list1

list3 \<- NULL

list1[[2]] \<- list1[[2]][-9]

list1

\`\`\`

\<br\>\<br\>

\> \*\*예제\*\*

\>

\> 1에서 10까지의 원소를 갖는 벡터 a와 11에서 15까지의 원소를 갖는 벡터 b를 생성하고 "example"이라는 문자와 함께 nlist 라는 리스트를 만들어 보자.
각 성분의 이름은 벡터 a는 vec1, 벡터 b는 vec2, "example"은 descrip 이라고 지정하도록 한다

\`\`\`{r}

a \<- c(1:10)

b \<- c(11:15)

nlist \<- list(vec1=a, vec2=b, descrip="example")

nlist

nlist[[2]][5]

nlist\$vec2[c(2,3)]

\`\`\`

\<br\>\<br\>

\#\#\#\# 3.6 데이터 프레임

\- 행렬과 비슷한 형태이나 행렬은 차원으로 표시되며 같은 형태의 객체를 가진다

\- 데이터 프레임은 각 열들이 서로 다른 형태의 객체를 가질 수 있다

\- 형태가 일반화된 행렬이다

\- 하나의 객체에 여러 종류의 자료가 들어갈 수 있다

\- 테이터 프레임의 각 열은 각각 다른 변수와 대응한다

\- 분석이나 모형 설정에 적합한 자료 객체이다

\<br\>\<br\>

\#\#\#\#\# 3.6.1 테이터 프레임의 생성

\- read.table() : 외부 텍스트 파일을 불러 들임.

\- data.frame() : 여러 종류의 자료 객체들을 서로 결합

\- as.data.frame() : 다른 형태의 객체 자료를 데이터 프레임 형태로 변환

\> \*\*예제\*\*

\>

\> 데이터가 다음과 같이 작성되어 story.txt 에 저장되어 있다고 가정하다.
read.table() 함수를 이용해 이 파일을 읽어보자

\>

\> \|num\|name\|age\|sex\|

\> \|:--:\|:--:\|:--:\|:--:\|

\> \|1\|Lee\|55\|M\|

\> \|2\|Park\|47\|F\|

\> \|3\|So\|35\|M\|

\> \|4\|Kim\|26\|F\|

\> \|5\|Yoon\|29\|M\|

\`\`\`{r}

d2 \<- read.table("story.txt", row.names="num", header=T)

d2

\`\`\`
